import{_ as n,c as s,o as a,U as p,bW as e,bX as l,bY as i,bZ as t,b_ as c,b$ as r,c0 as o,c1 as h,c2 as d}from"./chunks/framework.FpOEJISx.js";const N=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/backend/部署/Nginx.md","filePath":"docs/backend/部署/Nginx.md"}'),g={name:"docs/backend/部署/Nginx.md"},u=p('<h2 id="nginx简介" tabindex="-1">nginx简介 <a class="header-anchor" href="#nginx简介" aria-label="Permalink to &quot;nginx简介&quot;">​</a></h2><p>Nginx是俄罗斯人编写的十分轻量级的HTTP服务器,Nginx，它的发音为“engine X”，是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP 代理服务器。 Nginx以事件驱动的方式编写，所以有非常好的性能，同时也是一个非常高效的反向代理、负载平衡。 Nginx做为HTTP服务器，有以下几项基本特性：</p><ul><li>处理静态文件，索引文件以及自动索引；打开文件描述符缓冲</li><li>无缓存的反向代理加速，简单的负载均衡和容错</li><li>FastCGI，简单的负载均衡和容错</li><li>模块化的结构。包括gzipping, byte ranges，chunked responses，以及 SSI-filter等filter。如果由FastCGI或其它代理服务器处理单页中存在的多个SSI，则这项处理可以并行运行，而不需要相互等待</li><li>支持SSL 和 TLSSNI</li></ul><h2 id="正向代理" tabindex="-1">正向代理 <a class="header-anchor" href="#正向代理" aria-label="Permalink to &quot;正向代理&quot;">​</a></h2><p>我们在访问“你懂得”的网站的时候，需要挂“梯子”，这里的“梯子”就是正向代理。你访问“梯子”，“梯子”访问目标网站。一般情况下，我们可能没有权限直接访问目标地址，可以通过代理来访问目标地址。对于目标服务器来说，它只知道它在和代理服务器进行数据交换，而并不知道代理背后的客户端是谁，这就起到了隐藏客户端的作用。另外，可以通过代理服务器做数据统计，比如，我希望知道我的客户访问a网站多少次，访问b网站多少次，访问c网站多少次，用户访问代理服务器地址，代理服务做流量统计后，再将请求发到目的服务器。</p><p><img src="'+e+'" alt="Alt Text"></p><h2 id="反向代理" tabindex="-1">反向代理 <a class="header-anchor" href="#反向代理" aria-label="Permalink to &quot;反向代理&quot;">​</a></h2><p>反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器 P 地址。</p><p><img src="'+l+'" alt="Alt Text"></p><h2 id="负载均衡" tabindex="-1">负载均衡 <a class="header-anchor" href="#负载均衡" aria-label="Permalink to &quot;负载均衡&quot;">​</a></h2><p>客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。</p><p><img src="'+i+'" alt="Alt Text"></p><p>这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢?</p><p>我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢?</p><p>我们首先想到的可能是升级服务器的配置，比如提高 CPU 执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢?</p><p>上面的分析我们去掉了增加服务器物理配置来解决问题的办法,也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢?这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡</p><p><img src="'+t+'" alt="Alt Text"></p><h2 id="动静分离" tabindex="-1">动静分离 <a class="header-anchor" href="#动静分离" aria-label="Permalink to &quot;动静分离&quot;">​</a></h2><p>为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。隆低原来单个服务器的压力。</p><p><img src="'+c+'" alt="Alt Text"></p><p><img src="'+r+`" alt="Alt Text"></p><h2 id="nginx配置文件组成" tabindex="-1">nginx配置文件组成 <a class="header-anchor" href="#nginx配置文件组成" aria-label="Permalink to &quot;nginx配置文件组成&quot;">​</a></h2><h3 id="全局块" tabindex="-1">全局块 <a class="header-anchor" href="#全局块" aria-label="Permalink to &quot;全局块&quot;">​</a></h3><p>从配置文件开始到 events 块之间的内容，主要会设置一些影响 nginx 服务器整体运行的配指令，主要包括配置运行 Nginx 服务器的用户(组)、允许生成的 worker process 数，进程 PID 放路径、日志存放路径和类型以及配者文件的引入等。</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 默认为 1，表示开启一个业务进程，</span></span>
<span class="line"><span># 这是 Nginx 服务器并发处理服务的关键配置，&quot;worker_processes 值越大，可以支持的并发处理是也越多，但是会受到硬件、软件等设备的制约</span></span>
<span class="line"><span>worker_processes  1;</span></span>
<span class="line"><span>events {</span></span>
<span class="line"><span>    # 单个业务进程可接受连接数</span></span>
<span class="line"><span>    worker_connections  1024;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>http {</span></span>
<span class="line"><span>    # 引入 http mime 类型</span></span>
<span class="line"><span>    include       mime.types;</span></span>
<span class="line"><span>    # 如果 mime 类型没匹配上，默认使用二进制流的方式传输。</span></span>
<span class="line"><span>    default_type  application/octet-stream;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # sendfile() 高效网络传输，也就是数据 0 拷贝。</span></span>
<span class="line"><span>    sendfile        on;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    keepalive_timeout  65;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    server {</span></span>
<span class="line"><span>        # 监听端口号</span></span>
<span class="line"><span>        listen       80;</span></span>
<span class="line"><span>        # 虚拟主机名</span></span>
<span class="line"><span>        server_name  localhost;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        # 匹配路径</span></span>
<span class="line"><span>        location / {</span></span>
<span class="line"><span>            # 文件根目录</span></span>
<span class="line"><span>            root   html;</span></span>
<span class="line"><span>            # 默认页</span></span>
<span class="line"><span>            index  index.html index.htm;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        # 错误码对应页面</span></span>
<span class="line"><span>        error_page   500 502 503 504  /50x.html;</span></span>
<span class="line"><span>        location = /50x.html {</span></span>
<span class="line"><span>            root   html;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h3 id="events块" tabindex="-1">events块 <a class="header-anchor" href="#events块" aria-label="Permalink to &quot;events块&quot;">​</a></h3><p>events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 wordprocess 可以同时支持的最大连接数等。</p><p>上述例子就表示每个 work process 支持的最大连接数为 1024.</p><p>这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。</p><h3 id="http块" tabindex="-1">http块 <a class="header-anchor" href="#http块" aria-label="Permalink to &quot;http块&quot;">​</a></h3><p>这算 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。需要注意的是: http 块也可以包括 http 全局块、server 块。</p><h4 id="http全局块" tabindex="-1">http全局块 <a class="header-anchor" href="#http全局块" aria-label="Permalink to &quot;http全局块&quot;">​</a></h4><p>http 全局块配置的指令包括文件引入MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。</p><h4 id="server块" tabindex="-1">server块 <a class="header-anchor" href="#server块" aria-label="Permalink to &quot;server块&quot;">​</a></h4><p>这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。</p><p><strong>1、全局 server 块</strong> 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或 IP 配置。 <strong>2、location 块</strong> 一个 server 块可以配蛋多个 ocation 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串(例如 server_name/uri-string )，对虚主机名称(也可以是P 别名)之外的字符串(例如 前面的 /uri-string )进行配，对特定的请求进行处理，地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。</p><h2 id="实例" tabindex="-1">实例 <a class="header-anchor" href="#实例" aria-label="Permalink to &quot;实例&quot;">​</a></h2><h3 id="反向代理-1" tabindex="-1">反向代理 <a class="header-anchor" href="#反向代理-1" aria-label="Permalink to &quot;反向代理&quot;">​</a></h3><p><img src="`+o+'" alt="Alt Text"></p><p><strong>1.本地配置域名映射的ip地址</strong> C:\\Windows\\System32\\drivers\\etc 配置域名映射的ip地址 当我们访问www.123.com的时候首先回去本地电脑中的C:\\Windows\\System32\\drivers\\etc文件夹中查找域名对应的 ip 的地址，如果没有就会DNS中查找</p><p><img src="'+h+`" alt="Alt Text"></p><p>如果etc文件夹下没有hosts文件可如下解决：<a href="https://blog.csdn.net/weixin_45888898/article/details/109902984" target="_blank" rel="noreferrer">https://blog.csdn.net/weixin_45888898/article/details/109902984</a> 以管理员身份运行命令提示符：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>for /f %P in (&#39;dir %windir%\\WinSxS\\hosts /b /s&#39;) do copy %P %windir%\\System32\\drivers\\etc &amp; echo %P &amp; Notepad %P</span></span></code></pre></div><p><strong>2.在nginx进行请求转发的配置（反向代理配置）</strong></p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span># 指定了 Nginx 运行的用户或用户组。在这里，它将 Nginx 服务器的运行权限设置为 nginx 用户。</span></span>
<span class="line"><span>user nginx;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 设置Nginx服务器的工作进程数量。在这里，worker_processes 1;指定了Nginx服务器只使用一个工作进程来处理请求。</span></span>
<span class="line"><span>worker_processes 1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定Nginx服务器的错误日志文件路径为/var/log/nginx/error.log，并设置日志级别为warn。</span></span>
<span class="line"><span># 这意味着Nginx会将错误日志记录到指定的文件中，并只记录warn级别及以上的错误信息。</span></span>
<span class="line"><span>error_log /var/log/nginx/error.log warn;</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 指定了Nginx服务器的进程ID文件的路径为/var/run/nginx.pid。 N</span></span>
<span class="line"><span># ginx会将其进程ID写入这个文件，以便其他程序可以通过读取这个文件来获取Nginx的进程ID。</span></span>
<span class="line"><span>pid       /var/run/nginx.pid;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>events {</span></span>
<span class="line"><span>    # 设置了Nginx服务器的最大并发连接数为1024。</span></span>
<span class="line"><span>    worker_connections 1024;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>http {</span></span>
<span class="line"><span>    # 用于在Nginx服务器中指定文件类型。</span></span>
<span class="line"><span>    include           /etc/nginx/mime.types;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 设置了Nginx服务器在缺少文件类型信息时默认使用的文件类型为application/octet-stream。</span></span>
<span class="line"><span>    default_type      application/octet-stream;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 用来定义Nginx日志的格式。它包括了一系列变量，如请求的远程地址、用户、时间、请求内容、状态码、传输的字节数、引用来源、用户代理和转发地址。</span></span>
<span class="line"><span>    # 这个格式会被用于记录Nginx服务器的访问日志。</span></span>
<span class="line"><span>    log_format main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot;&#39;</span></span>
<span class="line"><span>                     &#39;$status $body_bytes_sent &quot;$http_referer&quot;&#39;</span></span>
<span class="line"><span>                     &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 指定Nginx服务器的访问日志文件路径为/var/log/nginx/access.log，并且使用名为main的日志格式来记录访问日志。</span></span>
<span class="line"><span>    access_log      /var/log/nginx/access.log main;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 启用Nginx服务器的文件传输优化功能，即将文件传输交给操作系统的sendfile系统调用来处理，以提高文件传输的效率和性能。</span></span>
<span class="line"><span>    sendfile        on;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 启用Nginx服务器的TCP_NOPUSH功能，该功能可以提高文件传输的效率和性能</span></span>
<span class="line"><span>    #tcp_nopush     on;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # 设置了Nginx服务器的keepalive超时时间为65秒。这指定了在客户端和服务器之间的持久连接中，如果在65秒内没有活动，则连接将被关闭。</span></span>
<span class="line"><span>    keepalive_timeout 65;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    # server可以写多个</span></span>
<span class="line"><span>    server {</span></span>
<span class="line"><span>        # 监听端口号</span></span>
<span class="line"><span>        listen       80;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        # 指定Nginx服务器的虚拟主机名为192.168.175.131(可以写成localhost)。</span></span>
<span class="line"><span>        # 当收到针对该主机名的请求时，Nginx将会使用这个server块中定义的配置来处理这些请求。</span></span>
<span class="line"><span>        server_name  192.168.175.131;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        # 匹配路径</span></span>
<span class="line"><span>        # 当访问的是 192.168.175.131/的时候将访问/usr/share/nginx/html目录下的index.html资源</span></span>
<span class="line"><span>        location / {</span></span>
<span class="line"><span>            # 指定Nginx服务器的根目录为/usr/share/nginx/html，这意味着当访问服务器时，Nginx将会从这个目录中提供文件。</span></span>
<span class="line"><span>            root   /usr/share/nginx/html;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            # 尝试按顺序查找当前请求的文件（$uri）、当前请求的目录（$uri/）以及/index.html文件，并返回找到的第一个存在的文件或目录。</span></span>
<span class="line"><span>            try_files $uri $uri/ /index.html;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            # 指定在访问特定路径时服务器应该返回的默认文件名。</span></span>
<span class="line"><span>            # 在这种情况下，当访问的路径是 / 时，服务器将首先尝试返回 index.html 文件，如果该文件不存在，则尝试返回 index.htm 文件。</span></span>
<span class="line"><span>            index  index.html index.htm;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        # 当访问的是 192.168.175.131/test 的时候将访问 http://192.168.175.131 ip下 8080端口中 test文件夹中的index.html文件</span></span>
<span class="line"><span>        location /test/ {</span></span>
<span class="line"><span>            # 设置代理请求的头部信息中的&quot;Host&quot;字段为客户端请求中的&quot;Host&quot;字段的值。</span></span>
<span class="line"><span>            proxy_set_header Host $http_host;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            # 设置代理请求的头部信息中的&quot;X-Real-IP&quot;字段为客户端请求的远程地址。</span></span>
<span class="line"><span>            proxy_set_header X-Real-IP $remote_addr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            # 设置代理请求的头部信息中的&quot;REMOTE-HOST&quot;字段为客户端请求的远程地址。</span></span>
<span class="line"><span>            proxy_set_header REMOTE-HOST $remote_addr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            # 设置代理请求的头部信息中的&quot;X-Forwarded-For&quot;字段为客户端请求的远程地址以及之前的&quot;X-Forwarded-For&quot;字段的值。</span></span>
<span class="line"><span>            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            # 将收到的请求代理到指定的地址和端口号上。在这种情况下，它将请求代理到 http://192.168.175.131:8080。</span></span>
<span class="line"><span>            # 注意这里的 http://192.168.175.131:8080;可以改为 其他ip + 其他端口</span></span>
<span class="line"><span>            proxy_pass http://192.168.175.131:8080;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        # 错误码对应页面</span></span>
<span class="line"><span>        error_page   500 502 503 504  /50x.html;</span></span>
<span class="line"><span>        location = /50x.html {</span></span>
<span class="line"><span>            root   html;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="跳板" tabindex="-1">跳板 <a class="header-anchor" href="#跳板" aria-label="Permalink to &quot;跳板&quot;">​</a></h2><h3 id="dockerfile文件" tabindex="-1">Dockerfile文件 <a class="header-anchor" href="#dockerfile文件" aria-label="Permalink to &quot;Dockerfile文件&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>FROM nginx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>COPY nginx.conf /etc/nginx/nginx.conf</span></span>
<span class="line"><span></span></span>
<span class="line"><span>EXPOSE 7891</span></span>
<span class="line"><span></span></span>
<span class="line"><span>ENV TZ=Asia/Shanghai</span></span>
<span class="line"><span></span></span>
<span class="line"><span>RUN chmod  -R 777 /usr/share/nginx/</span></span>
<span class="line"><span>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span></span></code></pre></div><h3 id="nginx-conf" tabindex="-1">nginx.conf <a class="header-anchor" href="#nginx-conf" aria-label="Permalink to &quot;nginx.conf&quot;">​</a></h3><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>user  nginx;</span></span>
<span class="line"><span>worker_processes  auto;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>error_log  /var/log/nginx/error.log notice;</span></span>
<span class="line"><span>pid        /var/run/nginx.pid;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>events {</span></span>
<span class="line"><span>    worker_connections  1024;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>http {</span></span>
<span class="line"><span>    include       /etc/nginx/mime.types;</span></span>
<span class="line"><span>    default_type  application/octet-stream;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span></span>
<span class="line"><span>                      &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span></span>
<span class="line"><span>                      &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    access_log  /var/log/nginx/access.log  main;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    sendfile        on;</span></span>
<span class="line"><span>    #tcp_nopush     on;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    keepalive_timeout  65;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    #gzip  on;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    include /etc/nginx/conf.d/*.conf;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>stream {</span></span>
<span class="line"><span>    upstream TEST_00000001 {</span></span>
<span class="line"><span>        server 192.10.49.107:7891;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>###################################################################################</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    server {</span></span>
<span class="line"><span>        listen       7891;</span></span>
<span class="line"><span>        proxy_pass TEST_00000001;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre></div><h2 id="nginx配置详解" tabindex="-1">nginx配置详解 <a class="header-anchor" href="#nginx配置详解" aria-label="Permalink to &quot;nginx配置详解&quot;">​</a></h2><p>网址：<a href="https://www.cnblogs.com/54chensongxia/p/12938929.html" target="_blank" rel="noreferrer">https://www.cnblogs.com/54chensongxia/p/12938929.html</a></p><h2 id="错误日志查看-容器" tabindex="-1">错误日志查看（容器） <a class="header-anchor" href="#错误日志查看-容器" aria-label="Permalink to &quot;错误日志查看（容器）&quot;">​</a></h2><p><img src="`+d+'" alt="Alt Text"></p>',54),x=[u];function m(_,b,q,v,f,k){return a(),s("div",null,x)}const w=n(g,[["render",m]]);export{N as __pageData,w as default};
