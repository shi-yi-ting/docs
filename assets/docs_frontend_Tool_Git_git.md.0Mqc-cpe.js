import{_ as t,c as i,o as e,U as a}from"./chunks/framework.FpOEJISx.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/frontend/Tool/Git/git.md","filePath":"docs/frontend/Tool/Git/git.md"}'),r={name:"docs/frontend/Tool/Git/git.md"},o=a('<h2 id="git-参考链接" tabindex="-1">Git<a href="https://juejin.cn/post/69261773318410731661" target="_blank" rel="noreferrer">(参考链接)</a> <a class="header-anchor" href="#git-参考链接" aria-label="Permalink to &quot;Git[(参考链接)](https://juejin.cn/post/69261773318410731661)&quot;">​</a></h2><h3 id="常用命令" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令" aria-label="Permalink to &quot;常用命令&quot;">​</a></h3><ul><li><strong>git init</strong> ---初始化一个 git 管理</li><li><strong>git status</strong> ---# 查看当前分支是否干净</li><li><strong>git checkout -b 分支名称</strong> ---# 创建一个新分支</li><li><strong>git branch</strong> ---# 查看所有分支查看本地所处分支</li><li><strong>git add .</strong> ---# 将所有文件保存到暂存区</li><li><strong>git commit -m &#39;xxx&#39;</strong> ---# 将代码提交到本地仓库中，xxx 为提交的备注信息</li><li><strong>git checkout master</strong> ---# 将分支切换到 master 分支上</li><li><strong>git merge login</strong> ---# 表示基于主分支主动的合并新建分支(login 分支)上的所有代码</li></ul><hr><ul><li><strong>git config -l</strong> 查看所有的配置,</li><li><strong>git config --system --list</strong> 命令查看一下系统配置</li><li><strong>git config --globa --list</strong> 命令查看 user.name 以及 email 等自定义配置</li></ul><hr><ul><li><strong>git stash</strong> ---存储临时改动</li><li><strong>git stash pop</strong> ---恢复改动</li></ul><hr><ul><li><strong>git branch -d 分支名称</strong> ---删除分支</li><li><strong>git branch -D 分支名称</strong> ---强制删除分支</li></ul><hr><ul><li><strong>git add 文件名.后缀</strong> ---将单个文件保存到暂存区</li><li><strong>git reset</strong> ---撤销之前的 git add 操作</li></ul><hr><ul><li><strong>git branch</strong> ---查看本地所处分支</li><li><strong>git branch -v</strong> ---查看本地分支信息</li><li><strong>git remote</strong> ---查看远程所处分支</li><li><strong>git remote -v</strong> ---查看远程分支信息</li></ul><hr><ul><li><strong>git remote add 别名 远程仓库地址</strong>---为远程仓取别名</li><li><strong>git push -u 别名 分支名称</strong>---(git push -u origin login -u 的作用是记住推送地址及分支,下次推送的时候直接执行 git push 即可)</li><li><strong>git push-u origin master</strong>---默认情况下降将本地 master 分支推送到远程仓的 master 分支</li><li><strong>git push origin dev:master</strong> ---dev 本地仓库分支名 : master 远程仓库分支名(将本地仓的 dev 分支推送到远程仓的 master 分支)</li></ul><hr><ul><li><strong>git clone</strong> 远程仓库地址 ---克隆远端仓库代码到本地（默认克隆远端 master 分支中的代码）</li><li><strong>git clone</strong> 远程仓库地址 --branch 分支名 （克隆指定分支的代码）</li></ul><hr><ul><li><strong>git fetch origin</strong> 远程仓分支名称 --- 拉取远端指定分支的代码（git fetch origin wuliu）</li><li><strong>git pull origin</strong> 远程仓分支名称 --- 拉取远端指定分支的代码并合并到本地分支（git pull origin wuliu）</li></ul><p><strong>fetch</strong>和<strong>pull</strong>的区别 fetch 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用, 但是注意的是 git fetch 并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><h3 id="编写代码前" tabindex="-1">编写代码前 <a class="header-anchor" href="#编写代码前" aria-label="Permalink to &quot;编写代码前&quot;">​</a></h3><p>开发新功能前建议新创建一个分支,在新分支上开发新功能</p><ol><li>执行 git status 查看当前分支是否干净</li><li>在 master 分支状态基础下,执行 git checkout-b 分支名称 创建一个新分支</li><li>执行 git branch 查看所有分支,查看目前所处分支是否在我们新建的分支上,打星号的表示我们目前所处的分支,</li><li>在所处新分支上进行代码的编写</li></ol><h3 id="代码完成后" tabindex="-1">代码完成后 <a class="header-anchor" href="#代码完成后" aria-label="Permalink to &quot;代码完成后&quot;">​</a></h3><ol><li>新分支上的新功能完成之后将代码提交到本地仓库中</li><li>执行 git status 查看目前项目中源代码的状态修改的和新添加的呈红色</li><li>在 login 新建分支状态下执行 git add . 将代码保存到暂存区保存到暂存区之后</li><li>执行 git status 产看状态可以看到都变成绿色了,表示都添加到了暂存区</li><li>执行 git commit -m &#39;xxx&#39; 将代码提交到本地仓库中(也就是新的分支上(login),提交前可以执行 git branch 查看是不是处于新建分支上</li></ol><h3 id="合并分支" tabindex="-1">合并分支 <a class="header-anchor" href="#合并分支" aria-label="Permalink to &quot;合并分支&quot;">​</a></h3><p>将新建的分支合并到 master 分支上</p><ol><li>执行 git checkout master 将分支切换到 master 分支上</li><li>执行 git branch 产看是否切换成功在主分支状态下</li><li>执行 git merge login 表示基于主分支主动的合并新建分支(login 分支)上的所有代码</li><li>在 master 分支状态下执行 git push 将本地仓库的代码上传到码云(远端仓库)</li></ol><h3 id="推送到远端仓库" tabindex="-1">推送到远端仓库 <a class="header-anchor" href="#推送到远端仓库" aria-label="Permalink to &quot;推送到远端仓库&quot;">​</a></h3><p>将本地新建的分支保存到码云(远端仓库)</p><ol><li>执行 git checkout login 切换到新建分支(login)分支上</li><li>执行 git branch 产看是否切换成功</li><li>执行 git push -u origin login 上传到码云(远端仓库),</li></ol><p>第一次提交后面建议加上 u origin,再次提交时直接执行 git push 即可 origin 为远端仓库地址的别名</p><h3 id="删除分支" tabindex="-1">删除分支 <a class="header-anchor" href="#删除分支" aria-label="Permalink to &quot;删除分支&quot;">​</a></h3><ol><li>git branch -d 分支名称 删除分支前 如果该分支未合并默认是不允许删除的</li><li>git branch -D 分支名称 强制删除分支即使未合并</li></ol><p>注意:删除分支需要切换到其他分支上才能删除目标分支</p><h3 id="暂时保存更改" tabindex="-1">暂时保存更改 <a class="header-anchor" href="#暂时保存更改" aria-label="Permalink to &quot;暂时保存更改&quot;">​</a></h3><ol><li>存储临时改动: git stash</li><li>恢复改动: git stash pop</li></ol><p>注意:是哪个分支执行的临时保存就在哪个分支恢复</p><h3 id="gitignore-文件" tabindex="-1">gitignore 文件 <a class="header-anchor" href="#gitignore-文件" aria-label="Permalink to &quot;gitignore 文件&quot;">​</a></h3><ol><li>该文件需手动创建</li><li>该文件的作用是排除掉一些特定的文件，使其在 git add . 时不会被添加到暂存区</li><li>使用 IDEA 集成的 Git：一般来说我们使用 IDEA 创建项目都会生成各种各样的文件,其中就有 .gitignore,这个文件的作用是排除掉一些特定的文件， 使其在 git add . 时不会被添加到暂存区,而我们使用 IDEA 打开刚刚的 git 项目则不会生成这个文件;需要我们手动的书写 在 IDEA 的 git 项目中如果创建或添加新文件,应该会弹出一个窗口它的意思是&quot;是否将如下文件添加到 git 中&quot;; 一般都勾选不再询问,并点击 cancel;这是个挺烦人的功能</li><li>使用 IDEA 打开该 git 项目后无疑会生成.idea 目录,这个目录我们不能将其删除;但我们可以将其写进 .gitignore 文件内;</li></ol><h3 id="gitee" tabindex="-1">Gitee <a class="header-anchor" href="#gitee" aria-label="Permalink to &quot;Gitee&quot;">​</a></h3><h4 id="为远程仓的地址取一个别名" tabindex="-1">为远程仓的地址取一个别名： <a class="header-anchor" href="#为远程仓的地址取一个别名" aria-label="Permalink to &quot;为远程仓的地址取一个别名：&quot;">​</a></h4><p>git remote add 别名 远程仓库地址如： git remote add origin <a href="mailto:git@gitee.com" target="_blank" rel="noreferrer">git@gitee.com</a>:shi_yi_ting/demo.git</p><h4 id="本地仓代码推送到远程仓" tabindex="-1">本地仓代码推送到远程仓 <a class="header-anchor" href="#本地仓代码推送到远程仓" aria-label="Permalink to &quot;本地仓代码推送到远程仓&quot;">​</a></h4><p>(-u 的作用是记住推送地址及分支,下次推送的时候直接执行 git push 即可) git push -u 别名 分支名称(要推送的分支名称) git push-u origin master 默认情况下降将本地 master 分支推送到远程仓的 master 分支 git push origin dev:master dev 本地仓库分支名 : master 远程仓库分支名(将本地仓的 dev 分支推送到远程仓的 master 分支)</p><h4 id="拉取远端代码" tabindex="-1">拉取远端代码 <a class="header-anchor" href="#拉取远端代码" aria-label="Permalink to &quot;拉取远端代码&quot;">​</a></h4><ol><li>复制远端地址然后右键执行 Git Clone git clone <a href="mailto:git@github.com" target="_blank" rel="noreferrer">git@github.com</a>:xxx.git (默认克隆远端 master 分支中的代码) git clone <a href="mailto:git@github.com" target="_blank" rel="noreferrer">git@github.com</a>:xxx.git --branch 分支名 (克隆指定分支的代码)(<a href="mailto:git@github.com" target="_blank" rel="noreferrer">git@github.com</a>:xxx.git 是你远程仓库的仓库地址)</li><li>使用 git 命令拉取远端指定分支的代码 git fetch/pull origin 远程仓分支名称 git fetch origin wuliu git pull origin wuliu</li><li>fetch 和 pull 的区别 fetch 这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用, 但是注意的是 git fetch 并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</li></ol><h3 id="遇到的问题" tabindex="-1">遇到的问题 <a class="header-anchor" href="#遇到的问题" aria-label="Permalink to &quot;遇到的问题&quot;">​</a></h3><p>从远端拉取代码执行 npm i 失败可尝试使用淘宝镜像进行安装：cnpm install</p><p>远程 push 推送出现 error: failed to push some refs to &#39;git@gitee.com:shi_yi_ting/demo.git</p><p>执行 git pull --rebase origin master 再执行 git push origin master</p><h4 id="远程-push-推送的时候出现-refusing-to-merge-unrelated" tabindex="-1">远程 push 推送的时候出现 refusing to merge unrelated <a class="header-anchor" href="#远程-push-推送的时候出现-refusing-to-merge-unrelated" aria-label="Permalink to &quot;远程 push 推送的时候出现 refusing to merge unrelated&quot;">​</a></h4><p>解决：$git pull origin master –allow-unrelated-histories $ git push 远程主机名 本地分支名:远程分支名 也就是 $git push origin master:master 出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接 clone 的方式在本地 建立起远程 github 仓库的克隆本地仓库就不会有这问题了。</p><h4 id="当执行-git-中的-git-pull-origin-master-–allow-unrelated-histories-命令时-会出现-couldn-t-find-remote-ref-–allow-unrelated-histories-的错误" tabindex="-1">当执行 git 中的“git pull origin master –allow-unrelated-histories”命令时，会出现“ couldn’t find remote ref –allow-unrelated-histories”的错误， <a class="header-anchor" href="#当执行-git-中的-git-pull-origin-master-–allow-unrelated-histories-命令时-会出现-couldn-t-find-remote-ref-–allow-unrelated-histories-的错误" aria-label="Permalink to &quot;当执行 git 中的“git pull origin master –allow-unrelated-histories”命令时，会出现“ couldn’t find remote ref –allow-unrelated-histories”的错误，&quot;">​</a></h4><p>输入如下命令即可解决： git pull --rebase origin master git push origin master</p><h3 id="理论" tabindex="-1">理论 <a class="header-anchor" href="#理论" aria-label="Permalink to &quot;理论&quot;">​</a></h3><h4 id="git" tabindex="-1">Git <a class="header-anchor" href="#git" aria-label="Permalink to &quot;Git&quot;">​</a></h4><h5 id="_1-git-有四个工作区域" tabindex="-1">1. git 有四个工作区域 <a class="header-anchor" href="#_1-git-有四个工作区域" aria-label="Permalink to &quot;1. git 有四个工作区域&quot;">​</a></h5><p>工作目录( Working Directory):</p><p>工作目录就是我们项目的存放位置除了使用 IDE 来生成,我们手动创建的文件夹也是一个工作目录</p><p>暂存区(tage/ndex):</p><p>暂存区在物理上并不存在它只是一个文件,用于保存一些提交列表信息,类似于清单,记录哪些內容会被提交到本地仓库。 本地仓库( Repository 或 Git Directory)用于存放暂存区提交过来的版本数据,它是一个目录; 该目录我们可以使用 git init 命令生成也可以使用 git clone 从远程拉取一个仓库作为</p><p>本地仓库:</p><p>这个目录里面所有的文件都可以被 Git 管理起来,每个文件的修改,删除等操作 Git 都可以跟踪到</p><p>远程仓库(Remote Directory):</p><p>就是所谓的 GithubGitee 等代码托管平台;我们可以通过与这些远程仓库取得连接的方式将本地仓库中的代码推送到远程仓库。 同样的我们也可以将远程仓库存放的代码拉取到我们的本地仓库中 这四个工作区域我们需要管理的仅有工作目录及远程仓库,另外的两个工作区域并不需要太多的管理</p><h5 id="_2-创建工作区域" tabindex="-1">2. 创建工作区域 <a class="header-anchor" href="#_2-创建工作区域" aria-label="Permalink to &quot;2. 创建工作区域&quot;">​</a></h5><p>工作目录:</p><p>除了使用 IDE 来生成,我们手动创建的文件夹也是一个工作目录</p><p>暂存区及本地仓库:</p><p>仅有工作目录是不能够满足我们使用 git 的条件,此时我们如果想使用 git 来管理我们的代码,我们需要在此文件夹内 右击并点击 GitBash here 在弹出的 Git Bash 中输入 git init 进行初始化操作, 初始化完成后会在该目录内生成 git 文件夹, 该文件夹为隐藏文件夹需要勾选&quot;隐藏的项目&quot;才可见,该文件夹生成后,该工作目录就已经被 git 托管，是一个 git 项目, 暂存区和本地仓库都已生成。我们也可以使用 git init 目录名的方式指定目录内生成.git 文件夹，二者都可</p><p>创建远程仓:</p><p>使用 GitHub 或 Gtee 我们都需要先注册一个平台账号,注册完毕点击头像左侧的&quot;+&quot;可以看到有 New repository 选项 点击该选项后会让我们填写仓库信息,填写完毕即可完成仓库的创建 完成创建后,我们的本地仓库和远程仓库都准备妥当了;我们要做的就是让二者对接,但在这之前我们需要准备一下 ssh 公钥,使用 ssh 安全连接,可以让我们在操作远程仓库时跳过用户信息的验证。</p><h3 id="git-配置" tabindex="-1">Git 配置 <a class="header-anchor" href="#git-配置" aria-label="Permalink to &quot;Git 配置&quot;">​</a></h3><p>如果你是第一次下载 git 的话应该自定义配置是空的,那你需要先进行用户信息的配置。可以使用命令的形式,也可以直接 找到配置文件进行修改。自定义配置的配置文件极大概率在你 c 盘下的对应用户文件夹内 gitconfig 一般只 需要配置用户名和 emal,这些用户配置会在你进行代码提交时起作用除自定义配置外,系统的配置则存放在 git 安装目录下的 etc 文件夹内; gitconfig 个人建议初学者不动系统配置。</p><h3 id="ssh-公钥" tabindex="-1">SSH 公钥 <a class="header-anchor" href="#ssh-公钥" aria-label="Permalink to &quot;SSH 公钥&quot;">​</a></h3><h4 id="获取公钥" tabindex="-1">获取公钥： <a class="header-anchor" href="#获取公钥" aria-label="Permalink to &quot;获取公钥：&quot;">​</a></h4><ol><li><p>进入 c 盘,找到自己对应的用户目录;在该目录下寻找 ssh 文件夹,在该文件夹下打开 Git bash 输入 <code>ssh-keygen</code> 命令可以创建 ssh 公钥文件,为了安全起见我们需要追加 t 选项, 将该公钥进行加密 <code>ssh-keygen -t rsa</code> rsa 加密算法是 gt 官方推荐的加密算法</p></li><li><p>使用该命令后会让你输入一些公钥信息,不知道怎么填可以全部按回车使用默认的信息 命令执行完毕会在 ssh 文件夹下生成两个文件,我们需要用到的是以 pub 为后缀的文件,即公钥文件。 公钥文件有了,我们回到 GitHub 点击头像下的 settings 选项,找到 SSH and GPG keys,在这里完成 ssh 安全连接</p></li><li><p>操作成功后,我们还不能直接将本地仓库中的文件 push 到 GitHub 远程仓库中;我们还需要进行一个远程仓库的绑定, 毕竟仓库可以有多个 GitHub 怎么能够知道你要将本地仓库中的文件提交到哪 绑定远程仓库我们可以使用 <code>git remote add origin</code> 远程仓库的 url 命令,绑定完我们就可以将我们本地仓库的文件推送到远 程仓库了。除了这种推送方式外,我们还可以通过仓库的克隆拿到已经对接好的本地仓库。这可以让我们偷很多懒,省却了初始化和远程仓库的绑定过程。</p></li></ol><h3 id="ssh-免登录" tabindex="-1">SSH 免登录 <a class="header-anchor" href="#ssh-免登录" aria-label="Permalink to &quot;SSH 免登录&quot;">​</a></h3><p>1.Htps 协议的远程仓库需进行身份验证,在正常情况下每一次向远程仓库推送代码都需要进行身份验证 (也就是每次需要登录账户密码) 只不过是我们使用 windows10 系统,在第一次登录之后操作系统帮助我们记住了用户名和密码</p><p>2.SSH 协议:这种协议在实现身份验证时不需要使用用户名密码可实现免登录操作,该协议的身份认证通过密钥实现的 (rsa:非对称的加密方式)</p><p>3.生成密钥:<code>ssh-keygen</code>(直接默认回车即可) 生成的密钥在系统的用户目录下的.ssh 文件夹中</p><p>4.登录 GitHub 进入网页 点击头像 选择 settings 选择 SSH and GPG keys 点击 New SSH key 把复制的公钥粘贴到 key 方框中 点击 Add SSH key 即可 登录 GitHub 进入网页 点击头像 选择 Yourrepositories(你的仓库) 选择目标仓库 点击 clone ordownload 点击 use SSH(会发现地址有所改变)</p><p>5.未使用 SSH 也可以免密登录的原因： window10 系统在登录 GitHub 之后会帮助我们记住用户名和密码,打开控制面板打开凭据管理器 windows 凭据可产看记住的信息</p><p>为仓库添加详细说明: 在项目的根目录下创建一个 README.md 文件,该文件会展示在仓库文件列表的下方</p><h2 id="github" tabindex="-1">GitHub <a class="header-anchor" href="#github" aria-label="Permalink to &quot;GitHub&quot;">​</a></h2><h3 id="团队多人合作" tabindex="-1">团队多人合作 <a class="header-anchor" href="#团队多人合作" aria-label="Permalink to &quot;团队多人合作&quot;">​</a></h3><p>1.A 程序员在本地创建本地仓库 登录 Github 账号创建远程仓库将本地仓库推送到远程仓库 2.B 程序员不需要创建仓库,只需要将 A 创建的远程仓库克隆到本地即可,然后进行本地开发, 开发完成之后将代码提交到本地仓库,然后推送到远程仓库</p><h4 id="a-程序员的初始化工作" tabindex="-1">A 程序员的初始化工作 <a class="header-anchor" href="#a-程序员的初始化工作" aria-label="Permalink to &quot;A 程序员的初始化工作&quot;">​</a></h4><p>1.本地创建文件夹在该文件夹中执行 git init 初始化一个本地仓库(会生成一个 git 文件),然后创建项目 执行 git add . 将项目提交到暂存区 执行 git commit -m &#39;xxx&#39; 将暂存区内容提交到本地仓库</p><p>2.创建远程仓库 进入 GitHub 个人中心页面点击 start a project 按钮创建创建仓库:填写仓库名称填写 owner(表示仓库的所有者)</p><p>3.将本地仓库推送到远程仓库 为远程仓库起一个别名: git remote add 别名 远程仓库地址 git remote add origin 地址 向远程仓库推送: git push -u 别名 分支名称(要推送的分支名称) git push-u origin master (使用 u 之后下次推送直接执行 git push 即可) 推送的其他方式和区别 git push 远程仓库地址 分支名称 git push 远程仓库地址 别名分支名称 git push -u 远程仓库地址别名 分支名称 u 的作用是记住推送地址及分支,下次推送的时候直接执行 git push 即可</p><h4 id="b-程序员的操作" tabindex="-1">B 程序员的操作 <a class="header-anchor" href="#b-程序员的操作" aria-label="Permalink to &quot;B 程序员的操作&quot;">​</a></h4><p>1.克隆 A 程序员推送到远程仓库中的项目 创建一个文件夹在文件夹中打开 Git Bash Here 执行 git clone 远程仓库地址 (登录打开 GitHub 浏览器网页,在远程仓库中有一个 clone or download 点开可看到仓库地址,复制使用)</p><p>2.B 程序员推送代码到远程仓库 B 程序员完成代码开发 将代码添加到暂存区 提交代码到本地仓库(也就是克隆的那个仓库)然后推送到远程仓库</p><h3 id="push-推送注意事项" tabindex="-1">push 推送注意事项 <a class="header-anchor" href="#push-推送注意事项" aria-label="Permalink to &quot;push 推送注意事项&quot;">​</a></h3><p>程序员 B 是不能直接向远程仓库提交代码的应为没有权限,此时需要 A 程序员邀请 B 程序员成为当前程序开发者,具体步骤如下： A 程序员登录的自己的 GitHub 账号在页面当中点击 settings 选择 Collaborators 填写程序员 B 的 GitHub 账号进行激活 点击 Copy invite link 复制邀请链接将链接发送给程序员 B 程序员 B 登录自己的 Github 账号访问这个邀请链接并接受邀请</p><h3 id="pull-拉取代码注意事项" tabindex="-1">pull 拉取代码注意事项 <a class="header-anchor" href="#pull-拉取代码注意事项" aria-label="Permalink to &quot;pull 拉取代码注意事项&quot;">​</a></h3><p>B 程序员拉取远程仓库中的代码 git pull 远程仓库的地址 分支名称 注意:如果远程仓库中的版本高于本地仓库的版本,此时本地仓库是不能向远程仓库中进行提交的,本地仓库必须要先拉取一下 代码然后再进行推送 push 失败则可尝试拉取一下代码再 push conflict(冲中突)</p><h3 id="冲突解决" tabindex="-1">冲突解决 <a class="header-anchor" href="#冲突解决" aria-label="Permalink to &quot;冲突解决&quot;">​</a></h3><p>如果两个人修改了同一个文件的同一个地方就会发生冲突,需要人为解决冲突 冲突解决之后需要 Git Sync -&gt;pull-&gt;resolved 一下(表示冲突已解决)这样就不会有感叹号了</p><h3 id="非团队合作" tabindex="-1">非团队合作 <a class="header-anchor" href="#非团队合作" aria-label="Permalink to &quot;非团队合作&quot;">​</a></h3><p>1.GitHub 除了支持团队协作之外还支持非团队协作,也就是说即使你不是团队成员,也有方法向其他人的 GitHub 仓库中提交代 码。只不过提交的代码需要对方通过审核</p><p>2.如何向其他人的远程仓库中提交代码? C 程序员登录 GitHub 并访问 A 程序员创建的仓库 C 程序员首先要<strong>fork 一下</strong>这个仓库(实际上就是将程序员 A 创建的仓库复制一份 并且放到自己(程序员 C)的 GHub 账号当中)</p><p>3.fork 之后这个复制的仓库就完全属于自己(程序员 C)的了，然后克隆代码 完善代码 添加到暂存区 提交到本地仓库 推送到自己的(C 程序员)远端仓库(Github)中</p><p>4.点击 pull request 点击 New pull request 点击 createpull request 填写标题以及说明填写之后 点击 create pull request 发送给原作者原作者在自己的 GHub 账号中的 pull request 可查看到别人发送过来的信息,也可进行回复</p><p>5.原作者点击 commits 可查看 C 程序员写的代码了 Files changed 可查看文件做了哪些修改,如果确认修改没有问题 点击 Merge pull request 合并代码 点击之后可填写信息(一般不做处理)</p><h3 id="git-和-tortoisegit-的安装-参考链接" tabindex="-1">Git 和 TortoiseGit 的安装<a href="https://wenku.baidu.com/view/8c9b6e38f9d6195f312b3169a45177232f60e4c0.html" target="_blank" rel="noreferrer">(参考链接)</a> <a class="header-anchor" href="#git-和-tortoisegit-的安装-参考链接" aria-label="Permalink to &quot;Git 和 TortoiseGit 的安装[(参考链接)](https://wenku.baidu.com/view/8c9b6e38f9d6195f312b3169a45177232f60e4c0.html)&quot;">​</a></h3><p>git 和 TortoiseGit 安装到指定文件夹默认安装即可，然后需要在 TortoiseGit 的设置中的网络中设置 D:\\soft\\soft\\Git\\Git\\usr\\bin\\ssh.exe（也就是 git 安装位置的相关内容）</p><h4 id="常见报错解决-参考链接" tabindex="-1">常见报错解决<a href="https://www.cnblogs.com/grootbaby/p/13827915.html" target="_blank" rel="noreferrer">(参考链接)</a> <a class="header-anchor" href="#常见报错解决-参考链接" aria-label="Permalink to &quot;常见报错解决[(参考链接)](https://www.cnblogs.com/grootbaby/p/13827915.html)&quot;">​</a></h4><p>tortoisegit(小乌龟)常见报错 No supported authentication methods available(server sent: publickey)</p><p>Git uses the concept of a hierarchical configuration the authenticity of host &#39;gitee.com&#39; can not be established 直接点击是即可，将会在.ssh 文件夹中生成 known_host 文件</p>',112),l=[o];function s(n,g,h,u,d,p){return e(),i("div",null,l)}const m=t(r,[["render",s]]);export{b as __pageData,m as default};
